
## 数据依赖, 关联

数据来源都可能是异步的

* 一对一依赖
b = a + 1

computed property, getter,
watcher 适合一对一, 其他情况较复杂

* 一对多依赖
c = a + b

* 多级依赖
a = b + 1
b = c + 1

## Observable, 数据逻辑

a: = b + c;
在传统方式下，这是一种一次性的赋值过程，调用一次就结束了，后面b和c再改变，a也不会变了。
在Reactive的理念中, 不是一次性赋值过程，而是可重复的赋值过程, 每次b或者c产生改变，这个表达式都会被重新计算

"异步的计算属性"
可复用数据链路
操作符, 数据管道, 拼装组合

--

同步与异步的统一(缓存)
查询和推送的统一
现在与未来的统一
可组合的数据变更过程, 数据管道
条件变更之后的自动重新计算
懒执行，不被订阅的数据流不执行
形拉实推，兼顾编写的便利性和执行的高效性

--

在传统的编程实践中，我们可以：

复用一种数据
复用一个函数
复用一组数据和函数的集合
但是，很难做到：`提供一种会持续变化的数据让其他模块复用`。

## 数据流
- 组件化

- MDV（Model Driven View）
模型驱动视图, 
V = f(M)
V + ΔV = f(M + ΔM)

ΔM = perform(action) 
state := actions.reduce(reducer, initState)
在初始状态上，依次叠加后续的变更，所得的就是当前状态。这就是数据流方案Redux的核心理念。
从整体来说，使用Redux，相当于把整个应用都实现为命令模式，一切变动都由命令驱动。
Redux这类东西出现的初衷只是为了提供一种单向数据流的思路，防止状态修改的混乱。但是在基于数据管道的这些库中，数据天然就是单向流动的

## 数据层

* 视图间的数据共享

 A | B | C
------------
前端的数据层
------------
  Server

 变更的数据产生某种消息
 使用者订阅这个消息，做一些后续处理
因此，数据层应当尽可能对外提供类似订阅方式的接口。


* 服务端推送
* 缓存的使用
* 数据的聚合

独立数据层的优势

1. 视图的极度轻量化。
2. 增强了整个应用的可测试性。
3. 跨端复用代码。
4. 可拆解的WebSocket补丁
